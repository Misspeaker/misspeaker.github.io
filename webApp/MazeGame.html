<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ëø∑ÂÆ´Êé¢Èô©</title>
    <style>
        :root {
            --wall-color: #2c3e50;
            --path-color: #ecf0f1;
            --player-color: #e74c3c;
            --exit-color: #2ecc71;
            --text-color: #2c3e50;
            --bg-color: #bdc3c7;
            --button-color: #3498db;
            --button-hover: #2980b9;
        }

        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.3s;
        }

        .dark-mode {
            --wall-color: #34495e;
            --path-color: #2c3e50;
            --player-color: #e74c3c;
            --exit-color: #27ae60;
            --text-color: #ecf0f1;
            --bg-color: #2c3e50;
            --button-color: #3498db;
            --button-hover: #2980b9;
        }

        header {
            width: 100%;
            background-color: var(--wall-color);
            color: white;
            padding:  1rem 0 5px 0;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 5px auto;
            width: 100%;
            max-width: 800px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .timer {
            font-size: 1.5rem;
            font-weight: bold;
            background-color: var(--wall-color);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .buttons {
            display: flex;
            gap: 1rem;
        }

        button {
            background-color: var(--button-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        button:hover {
            background-color: var(--button-hover);
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .maze-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1/1;
            background-color: var(--wall-color);
            border: 2px solid var(--wall-color);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .level-info {
            margin-top: 1rem;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .level-select {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
        }

        .level-btn {
            min-width: 40px;
        }

        .mobile-controls {
            display: none;
            margin-top: 1rem;
            width: 100%;
            max-width: 300px;
        }

        .mobile-controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            width: 100%;
            aspect-ratio: 1/1;
        }

        .mobile-btn {
            background-color: var(--button-color);
            color: white;
            border: none;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            user-select: none;
        }

        .mobile-btn:active {
            background-color: var(--button-hover);
        }

        .up { grid-area: 1 / 2; }
        .left { grid-area: 2 / 1; }
        .center { grid-area: 2 / 2; background-color: transparent; }
        .right { grid-area: 2 / 3; }
        .down { grid-area: 3 / 2; }

        .particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .theme-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--button-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 100;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: block;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
                gap: 1rem;
            }
            
            .buttons {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>Ëø∑ÂÆ´Êé¢Èô©</h1>
    </header>

    <div class="game-container">
        <div class="controls">
            <div class="timer">00:00.00</div>
            <div class="buttons">
                <button id="pauseBtn">ÊöÇÂÅú</button>
                <button id="restartBtn">ÈáçÁΩÆ</button>
                <button id="hintBtn">ÊèêÁ§∫</button>
            </div>
        </div>

        <div class="maze-container">
            <canvas id="mazeCanvas"></canvas>
            <div class="particles" id="particles"></div>
        </div>

        <div class="level-info">ÈöæÂ∫¶: <span id="currentLevel">1</span>/5</div>

        <div class="level-select">
            <button class="level-btn" data-level="1">1</button>
            <button class="level-btn" data-level="2">2</button>
            <button class="level-btn" data-level="3">3</button>
            <button class="level-btn" data-level="4">4</button>
            <button class="level-btn" data-level="5">5</button>
        </div>

        <div class="mobile-controls">
            <div class="mobile-controls-grid">
                <button class="mobile-btn up">‚Üë</button>
                <button class="mobile-btn left">‚Üê</button>
                <div class="center"></div>
                <button class="mobile-btn right">‚Üí</button>
                <button class="mobile-btn down">‚Üì</button>
            </div>
        </div>
    </div>

    <div class="theme-toggle" id="themeToggle">üåì</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Ê∏∏ÊàèÁä∂ÊÄÅ
            const gameState = {
                currentLevel: 1,
                maxUnlockedLevel: 1,
                isPaused: false,
                isGameOver: false,
                startTime: 0,
                currentTime: 0,
                timerInterval: null,
                playerPosition: { x: 1, y: 1 },
                exitPosition: { x: 0, y: 0 },
                maze: [],
                mazeWidth: 10,
                mazeHeight: 10,
                cellSize: 0,
                hintPath: [],
                showHint: false,
                bestTimes: {}
            };

            // ÂàùÂßãÂåñÊ∏∏Êàè
            try {
                const canvas = document.getElementById('mazeCanvas');
                const ctx = canvas?.getContext('2d');

                if (!canvas || !ctx) {
                    throw new Error('Canvas Êàñ‰∏ä‰∏ãÊñáÊú™Ê≠£Á°ÆÂàùÂßãÂåñ„ÄÇ');
                }

                // DOM ÂÖÉÁ¥†
                const elements = {
                    canvas,
                    ctx,
                    timer: document.querySelector('.timer'),
                    currentLevel: document.getElementById('currentLevel'),
                    pauseBtn: document.getElementById('pauseBtn'),
                    restartBtn: document.getElementById('restartBtn'),
                    hintBtn: document.getElementById('hintBtn'),
                    levelBtns: document.querySelectorAll('.level-btn'),
                    mobileBtns: document.querySelectorAll('.mobile-btn'),
                    particles: document.getElementById('particles'),
                    themeToggle: document.getElementById('themeToggle'),
                    body: document.body
                };

                // ÂÖ≥Âç°ÈÖçÁΩÆ
                const levels = [
                    { width: 15, height: 15, complexity: 0.1, density: 0.15 }, // Level 1
                    { width: 19, height: 19, complexity: 0.2, density: 0.15 }, // Level 2
                    { width: 25, height: 25, complexity: 0.3, density: 0.2 },  // Level 3
                    { width: 31, height: 31, complexity: 0.4, density: 0.2 }, // Level 4
                    { width: 37, height: 37, complexity: 0.5, density: 0.3 }   // Level 5
                ];

                // ‰ºòÂåñÁöÑËø∑ÂÆ´ÁîüÊàêÂáΩÊï∞
                function generateMaze(levelConfig) {
                    const maxAttempts = 6;
                    let attempts = 0;
                    
                    while (attempts < maxAttempts) {
                        try {
                            gameState.mazeWidth = levelConfig.width;
                            gameState.mazeHeight = levelConfig.height;
                            gameState.maze = Array(gameState.mazeHeight).fill().map(() => Array(gameState.mazeWidth).fill(1));
                            gameState.playerPosition = { x: 1, y: 1 };
                            gameState.exitPosition = { x: gameState.mazeWidth - 2, y: gameState.mazeHeight - 2 };
                            
                            // ‰ΩøÁî®ÊîπËøõÂêéÁöÑDFSÁîüÊàêËø∑ÂÆ´
                            dfsGenerate(1, 1);
                            
                            // Á°Æ‰øùËµ∑ÁÇπÂíåÁªàÁÇπ‰∏∫Ë∑ØÂæÑ
                            gameState.maze[1][1] = 0;
                            gameState.maze[gameState.exitPosition.y][gameState.exitPosition.x] = 0;
                            
                            // È™åËØÅËø∑ÂÆ´ÊòØÂê¶ÊúâÂèØËææË∑ØÂæÑ
                            if (validatePath()) {
                                calculateCellSize();
                                generateHintPath();
                                return true;
                            }
                        } catch (error) {
                            console.warn(`Ëø∑ÂÆ´ÁîüÊàêÂ∞ùËØï ${attempts + 1} Â§±Ë¥•:`, error);
                        }
                        attempts++;
                    }
                    throw new Error('Êó†Ê≥ïÁîüÊàêÊúâÊïàËø∑ÂÆ´ÔºåËØ∑ÈáçËØï');
                }

                // ÊîπËøõÁöÑDFSÁîüÊàêÁÆóÊ≥ï
                function dfsGenerate(x, y) {
                    const directions = [
                        [2, 0], [-2, 0], [0, 2], [0, -2]
                    ].sort(() => Math.random() - 0.5);
                    
                    gameState.maze[y][x] = 0;
                    
                    for (const [dx, dy] of directions) {
                        const nextX = x + dx;
                        const nextY = y + dy;
                        const wallX = x + dx/2;
                        const wallY = y + dy/2;
                        
                        if (isValidCell(nextX, nextY) && gameState.maze[nextY][nextX] === 1) {
                            gameState.maze[wallY][wallX] = 0;
                            dfsGenerate(nextX, nextY);
                        }
                    }
                }

                // È™åËØÅË∑ØÂæÑÊòØÂê¶ÂèØËææ
                function validatePath() {
                    const visited = Array(gameState.mazeHeight).fill().map(() => Array(gameState.mazeWidth).fill(false));
                    const queue = [{...gameState.playerPosition}];
                    visited[gameState.playerPosition.y][gameState.playerPosition.x] = true;
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        
                        if (current.x === gameState.exitPosition.x && current.y === gameState.exitPosition.y) {
                            return true;
                        }
                        
                        for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                            const nx = current.x + dx;
                            const ny = current.y + dy;
                            
                            if (isValidCell(nx, ny) && gameState.maze[ny][nx] === 0 && !visited[ny][nx]) {
                                visited[ny][nx] = true;
                                queue.push({x: nx, y: ny});
                            }
                        }
                    }
                    return false;
                }

                // ÂàùÂßãÂåñËø∑ÂÆ´ÁΩëÊ†º
                function initializeMazeGrid(levelConfig) {
                    gameState.mazeWidth = levelConfig.width;
                    gameState.mazeHeight = levelConfig.height;
                    gameState.maze = Array(gameState.mazeHeight).fill().map(() => 
                        Array(gameState.mazeWidth).fill(1)
                    );
                    gameState.playerPosition = { x: 1, y: 1 };
                    gameState.exitPosition = { 
                        x: gameState.mazeWidth - 2, 
                        y: gameState.mazeHeight - 2 
                    };
                }

                // ‰ΩøÁî®DFSÁÆóÊ≥ïÈõïÂàªËø∑ÂÆ´Ë∑ØÂæÑ
                function carvePathsByDFS(x, y) {
                    const directions = [
                        [2, 0], [-2, 0], [0, 2], [0, -2]
                    ];
                    
                    // ÈöèÊú∫Êâì‰π±ÊñπÂêë
                    directions.sort(() => Math.random() - 0.5);
                    
                    gameState.maze[y][x] = 0;
                    
                    for (const [dx, dy] of directions) {
                        const nextX = x + dx;
                        const nextY = y + dy;
                        const wallX = x + dx/2;
                        const wallY = y + dy/2;
                        
                        if (isValidCell(nextX, nextY) && gameState.maze[nextY][nextX] === 1) {
                            gameState.maze[wallY][wallX] = 0; // ÊâìÈÄöÂ¢ôÂ£Å
                            carvePathsByDFS(nextX, nextY);
                        }
                    }
                }

                // Á°Æ‰øùËµ∑ÁÇπÂíåÁªàÁÇπÂèØÁî®
                function ensureStartAndEnd() {
                    const { playerPosition, exitPosition } = gameState;
                    
                    gameState.maze[playerPosition.y][playerPosition.x] = 0;
                    gameState.maze[exitPosition.y][exitPosition.x] = 0;
                    
                    // Á°Æ‰øùËµ∑ÁÇπÂíåÁªàÁÇπÂë®Âõ¥ÊúâË∑Ø
                    for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                        const startX = playerPosition.x + dx;
                        const startY = playerPosition.y + dy;
                        const endX = exitPosition.x + dx;
                        const endY = exitPosition.y + dy;
                        
                        if (isValidCell(startX, startY)) {
                            gameState.maze[startY][startX] = 0;
                        }
                        if (isValidCell(endX, endY)) {
                            gameState.maze[endY][endX] = 0;
                        }
                    }
                }

                // È™åËØÅËø∑ÂÆ´ÊòØÂê¶ÊúâÊïà
                function validateMaze() {
                    const visited = Array(gameState.mazeHeight).fill().map(() => 
                        Array(gameState.mazeWidth).fill(false)
                    );
                    
                    const queue = [gameState.playerPosition];
                    visited[gameState.playerPosition.y][gameState.playerPosition.x] = true;
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        
                        if (current.x === gameState.exitPosition.x && 
                            current.y === gameState.exitPosition.y) {
                            return true;
                        }
                        
                        for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                            const nx = current.x + dx;
                            const ny = current.y + dy;
                            
                            if (isValidCell(nx, ny) && 
                                gameState.maze[ny][nx] === 0 && 
                                !visited[ny][nx]) {
                                visited[ny][nx] = true;
                                queue.push({ x: nx, y: ny });
                            }
                        }
                    }
                    
                    return false;
                }

                // Ê£ÄÊü•ÂçïÂÖÉÊ†ºÊòØÂê¶ÊúâÊïà
                function isValidCell(x, y) {
                    return x > 0 && x < gameState.mazeWidth - 1 && 
                           y > 0 && y < gameState.mazeHeight - 1;
                }

                // ÁÆÄÂåñÁöÑÂ≠òÂÇ®ÁÆ°ÁêÜ
                const storage = {
                    save: (key, data) => {
                        try {
                            localStorage.setItem(key, JSON.stringify(data));
                        } catch (error) {
                            console.error('Â≠òÂÇ®Êï∞ÊçÆÂ§±Ë¥•:', error);
                        }
                    },
                    load: (key, defaultValue = null) => {
                        try {
                            const data = localStorage.getItem(key);
                            return data ? JSON.parse(data) : defaultValue;
                        } catch (error) {
                            console.error('ËØªÂèñÊï∞ÊçÆÂ§±Ë¥•:', error);
                            return defaultValue;
                        }
                    }
                };

                // Ëø∑ÂÆ´ÁîüÊàêÂô®Á±ª
                class MazeGenerator {
                    constructor(width, height) {
                        this.width = width;
                        this.height = height;
                        this.maze = Array(height).fill().map(() => Array(width).fill(1));
                    }
                
                    // ÁîüÊàêËø∑ÂÆ´
                    generate() {
                        // ÂàùÂßãÂåñËµ∑ÁÇπÂíåÁªàÁÇπ
                        const start = { x: 1, y: 1 };
                        const end = { x: this.width - 2, y: this.height - 2 };
                
                        // Ê∏ÖÁ©∫Ëµ∑ÁÇπÂíåÁªàÁÇπ
                        this.maze[start.y][start.x] = 0;
                        this.maze[end.y][end.x] = 0;
                
                        // ‰ªéËµ∑ÁÇπÂºÄÂßãÁîüÊàêËø∑ÂÆ´
                        this.carvePassages(start.x, start.y);
                        
                        // Á°Æ‰øùÁªàÁÇπÂèØËææ
                        this.ensureEndReachable(end.x, end.y);
                        
                        return this.maze;
                    }
                
                    // ÈõïÂàªÈÄöÈÅì
                    carvePassages(x, y) {
                        const directions = [
                            [0, -2], [2, 0], [0, 2], [-2, 0]
                        ].sort(() => Math.random() - 0.5);
                
                        for (const [dx, dy] of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                
                            if (this.isInBounds(nx, ny) && this.maze[ny][nx] === 1) {
                                this.maze[y + dy/2][x + dx/2] = 0;
                                this.maze[ny][nx] = 0;
                                this.carvePassages(nx, ny);
                            }
                        }
                    }
                
                    // Á°Æ‰øùÁªàÁÇπÂèØËææ
                    ensureEndReachable(endX, endY) {
                        // Â¶ÇÊûúÊó†Ê≥ïÂà∞ËææÁªàÁÇπÔºåÂàõÂª∫‰∏ÄÊù°Áõ¥Êé•ÈÄöÈÅì
                        if (!this.pathExists({ x: 1, y: 1 }, { x: endX, y: endY })) {
                            let x = endX, y = endY;
                            while (x > 1 || y > 1) {
                                this.maze[y][x] = 0;
                                if (x > 1) x--;
                                if (y > 1) y--;
                                this.maze[y][x] = 0;
                            }
                        }
                    }
                
                    // Ê£ÄÊü•Ë∑ØÂæÑÊòØÂê¶Â≠òÂú®
                    pathExists(start, end) {
                        const visited = Array(this.height).fill().map(() => Array(this.width).fill(false));
                        const queue = [start];
                        visited[start.y][start.x] = true;
                
                        while (queue.length > 0) {
                            const current = queue.shift();
                            if (current.x === end.x && current.y === end.y) return true;
                
                            for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
                                const nx = current.x + dx;
                                const ny = current.y + dy;
                                if (this.isInBounds(nx, ny) && this.maze[ny][nx] === 0 && !visited[ny][nx]) {
                                    visited[ny][nx] = true;
                                    queue.push({ x: nx, y: ny });
                                }
                            }
                        }
                        return false;
                    }
                
                    // Ê£ÄÊü•ÂùêÊ†áÊòØÂê¶Âú®Ëø∑ÂÆ´ËåÉÂõ¥ÂÜÖ
                    isInBounds(x, y) {
                        return x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1;
                    }
                }
                
                // ÂàùÂßãÂåñÊ∏∏Êàè
                function initGame() {
                    try {
                        // Âä†ËΩΩÊ∏∏ÊàèËøõÂ∫¶
                        const savedProgress = storage.load('mazeGameProgress', { maxUnlockedLevel: 1, bestTimes: {} });
                        gameState.maxUnlockedLevel = savedProgress.maxUnlockedLevel;
                        gameState.bestTimes = savedProgress.bestTimes;
                
                        // ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨
                        setupEventListeners();
                
                        // ÁîüÊàêÂàùÂßãËø∑ÂÆ´
                        const level = levels[gameState.currentLevel - 1];
                        const generator = new MazeGenerator(level.width, level.height);
                        gameState.maze = generator.generate();
                        gameState.mazeWidth = level.width;
                        gameState.mazeHeight = level.height;
                        
                        // ÂàùÂßãÂåñÁä∂ÊÄÅ
                        gameState.playerPosition = { x: 1, y: 1 };
                        gameState.exitPosition = { x: level.width - 2, y: level.height - 2 };

                        //ÂàùÂßãÂøÖÈáçÁΩÆ‰∏ÄÊ¨°Ëø∑ÂÆ´
                        restartLevel();
                
                        // Êõ¥Êñ∞ÊòæÁ§∫
                        calculateCellSize();
                        generateHintPath();
                        startTimer();
                        renderMaze();
                        updateLevelButtons();
                    } catch (error) {
                        console.error('Ê∏∏ÊàèÂàùÂßãÂåñÂ§±Ë¥•:', error);
                        alert('Ëø∑ÂÆ´ÁîüÊàêÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï');
                    }
                }
                
                // ‰øÆÊîπÈáçÊñ∞ÂºÄÂßãÂÖ≥Âç°ÂáΩÊï∞
                function restartLevel() {
                    try {
                        gameState.isPaused = false;
                        gameState.isGameOver = false;
                        elements.pauseBtn.textContent = 'ÊöÇÂÅú';
                
                        const level = levels[gameState.currentLevel - 1];
                        const generator = new MazeGenerator(level.width, level.height);
                        gameState.maze = generator.generate();
                        gameState.playerPosition = { x: 1, y: 1 };
                        
                        startTimer();
                        renderMaze();
                    } catch (error) {
                        console.error('ÈáçÊñ∞ÂºÄÂßãÂÖ≥Âç°Â§±Ë¥•:', error);
                        alert('Ëø∑ÂÆ´ÁîüÊàêÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï');
                    }
                }
                
                // ‰øÆÊîπÂàáÊç¢ÂÖ≥Âç°ÂáΩÊï∞
                function changeLevel(level) {
                    if (level < 1 || level > levels.length) return;
                    
                    try {
                        gameState.currentLevel = level;
                        gameState.isPaused = false;
                        gameState.isGameOver = false;
                        elements.pauseBtn.textContent = 'ÊöÇÂÅú';
                        elements.currentLevel.textContent = level;
                
                        const levelConfig = levels[level - 1];
                        const generator = new MazeGenerator(levelConfig.width, levelConfig.height);
                        gameState.maze = generator.generate();
                        gameState.mazeWidth = levelConfig.width;
                        gameState.mazeHeight = levelConfig.height;
                        gameState.playerPosition = { x: 1, y: 1 };
                        gameState.exitPosition = { x: levelConfig.width - 2, y: levelConfig.height - 2 };
                
                        calculateCellSize();
                        generateHintPath();
                        startTimer();
                        renderMaze();
                    } catch (error) {
                        console.error('ÂàáÊç¢ÂÖ≥Âç°Â§±Ë¥•:', error);
                        alert('Ëø∑ÂÆ´ÁîüÊàêÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï');
                    }
                }

                // ËÆæÁΩÆ‰∫ã‰ª∂ÁõëÂê¨Âô®
                function setupEventListeners() {
                    // ÈîÆÁõòÊéßÂà∂
                    document.addEventListener('keydown', handleKeyDown);
                    
                    // ÊåâÈíÆ‰∫ã‰ª∂
                    elements.pauseBtn.addEventListener('click', togglePause);
                    elements.restartBtn.addEventListener('click', restartLevel);
                    elements.hintBtn.addEventListener('click', toggleHint);
                    
                    // ÂÖ≥Âç°ÈÄâÊã©
                    elements.levelBtns.forEach(btn => {
                        btn.addEventListener('click', () => {
                            const level = parseInt(btn.dataset.level);
                            if (level <= gameState.maxUnlockedLevel) {
                                changeLevel(level);
                            }
                        });
                    });
                    
                    // ÁßªÂä®Á´ØÊéßÂà∂
                    elements.mobileBtns.forEach(btn => {
                        btn.addEventListener('click', () => {
                            if (btn.textContent === '‚Üë') movePlayer(0, -1);
                            if (btn.textContent === '‚Üì') movePlayer(0, 1);
                            if (btn.textContent === '‚Üê') movePlayer(-1, 0);
                            if (btn.textContent === '‚Üí') movePlayer(1, 0);
                        });
                    });
                    
                    // ‰∏ªÈ¢òÂàáÊç¢
                    elements.themeToggle.addEventListener('click', toggleTheme);
                }

                // ÂàáÊç¢‰∏ªÈ¢ò
                function toggleTheme() {
                    elements.body.classList.toggle('dark-mode');
                    renderMaze();
                }

                // ÁîüÊàêËø∑ÂÆ´ (‰ΩøÁî®Ê∑±Â∫¶‰ºòÂÖàÊêúÁ¥¢ÁÆóÊ≥ï)
                function generateMaze(levelConfig) {
                    gameState.mazeWidth = levelConfig.width;
                    gameState.mazeHeight = levelConfig.height;
                    gameState.maze = Array(gameState.mazeHeight).fill().map(() => Array(gameState.mazeWidth).fill(1));
                    gameState.playerPosition = { x: 1, y: 1 };
                    gameState.exitPosition = { x: gameState.mazeWidth - 2, y: gameState.mazeHeight - 2 };
                    dfsGenerate(1, 1, levelConfig.complexity, levelConfig.density);
                    gameState.maze[1][1] = 0;
                    gameState.maze[gameState.exitPosition.y][gameState.exitPosition.x] = 0;

                    // Â¶ÇÊûúË∑ØÂæÑ‰∏çÂèØËææÔºåÂàôÂº∫Âà∂ËøûÊé•Ëµ∑ÁÇπÂíåÁªàÁÇπ
                    if (!ensurePath()) {
                        forceConnectPath();
                    }

                    calculateCellSize();
                    generateHintPath();
                }

                // Êñ∞Â¢ûÔºöÂº∫Âà∂ËøûÊé•Ëµ∑ÁÇπÂíåÁªàÁÇπÁöÑÂáΩÊï∞
                function forceConnectPath() {
                    let { x: curX, y: curY } = gameState.playerPosition;
                    const { x: exitX, y: exitY } = gameState.exitPosition;

                    // Ê®™ÂêëËøûÊé•
                    while (curX !== exitX) {
                        gameState.maze[curY][curX] = 0;
                        curX += exitX > curX ? 1 : -1;
                    }

                    // Á∫µÂêëËøûÊé•
                    while (curY !== exitY) {
                        gameState.maze[curY][curX] = 0;
                        curY += exitY > curY ? 1 : -1;
                    }
                }

                // Ê∑±Â∫¶‰ºòÂÖàÊêúÁ¥¢ÁîüÊàêËø∑ÂÆ´
                function dfsGenerate(x, y, complexity, density) {
                    const directions = [
                        [1, 0], [-1, 0], [0, 1], [0, -1]
                    ].sort(() => Math.random() - 0.5);
                    
                    gameState.maze[y][x] = 0;
                    
                    for (const [dx, dy] of directions) {
                        const nx = x + dx * 2;
                        const ny = y + dy * 2;
                        
                        if (nx > 0 && nx < gameState.mazeWidth - 1 && 
                            ny > 0 && ny < gameState.mazeHeight - 1 && 
                            gameState.maze[ny][nx] === 1) {
                            
                            gameState.maze[y + dy][x + dx] = 0;
                            dfsGenerate(nx, ny, complexity, density);
                        }
                    }
                }

                // Á°Æ‰øùËø∑ÂÆ´ÊúâÈÄöË∑Ø
                function ensurePath() {
                    const { maze, playerPosition, exitPosition } = gameState;
                    const visited = Array(maze.length).fill().map(() => Array(maze[0].length).fill(false));
                    const stack = [playerPosition];
                    visited[playerPosition.y][playerPosition.x] = true;

                    while (stack.length > 0) {
                        const { x, y } = stack.pop();
                        if (x === exitPosition.x && y === exitPosition.y) return true;

                        for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                            const nx = x + dx;
                            const ny = y + dy;

                            if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length &&
                                maze[ny][nx] === 0 && !visited[ny][nx]) {
                                visited[ny][nx] = true;
                                stack.push({ x: nx, y: ny });
                            }
                        }
                    }
                    return false;
                }

                // ËÆ°ÁÆóÂçïÂÖÉÊ†ºÂ§ßÂ∞è
                function calculateCellSize() {
                    const container = document.querySelector('.maze-container');
                    const containerWidth = container.clientWidth;
                    const containerHeight = container.clientHeight;
                    
                    gameState.cellSize = Math.min(
                        containerWidth / gameState.mazeWidth,
                        containerHeight / gameState.mazeHeight
                    );
                    
                    elements.canvas.width = gameState.mazeWidth * gameState.cellSize;
                    elements.canvas.height = gameState.mazeHeight * gameState.cellSize;
                }

                // Ê∏≤ÊüìËø∑ÂÆ´
                function renderMaze() {
                    const { ctx, canvas } = elements;
                    const { maze, cellSize, playerPosition, exitPosition } = gameState;
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // ÁªòÂà∂Ëø∑ÂÆ´
                    for (let y = 0; y < maze.length; y++) {
                        for (let x = 0; x < maze[y].length; x++) {
                            if (maze[y][x] === 1) {
                                // Â¢ôÂ£Å
                                ctx.fillStyle = getComputedStyle(document.documentElement)
                                    .getPropertyValue('--wall-color');
                                
                                // Ê∑ªÂä†3DÊïàÊûú
                                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                                ctx.shadowBlur = 2;
                                ctx.shadowOffsetX = 2;
                                ctx.shadowOffsetY = 2;
                                
                                ctx.fillRect(
                                    x * cellSize, 
                                    y * cellSize, 
                                    cellSize, 
                                    cellSize
                                );
                                
                                // ÈáçÁΩÆÈò¥ÂΩ±
                                ctx.shadowColor = 'transparent';
                            } else {
                                // Ë∑ØÂæÑ
                                ctx.fillStyle = getComputedStyle(document.documentElement)
                                    .getPropertyValue('--path-color');
                                ctx.fillRect(
                                    x * cellSize, 
                                    y * cellSize, 
                                    cellSize, 
                                    cellSize
                                );
                            }
                        }
                    }
                    
                    // ÁªòÂà∂ÊèêÁ§∫Ë∑ØÂæÑ
                    if (gameState.showHint && gameState.hintPath.length > 0) {
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        for (const {x, y} of gameState.hintPath) {
                            ctx.fillRect(
                                x * cellSize + cellSize * 0.25,
                                y * cellSize + cellSize * 0.25,
                                cellSize * 0.5,
                                cellSize * 0.5
                            );
                        }
                    }
                    
                    // ÁªòÂà∂Âá∫Âè£
                    ctx.fillStyle = getComputedStyle(document.documentElement)
                        .getPropertyValue('--exit-color');
                    ctx.beginPath();
                    ctx.arc(
                        exitPosition.x * cellSize + cellSize / 2,
                        exitPosition.y * cellSize + cellSize / 2,
                        cellSize / 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    // ÁªòÂà∂Áé©ÂÆ∂
                    ctx.fillStyle = getComputedStyle(document.documentElement)
                        .getPropertyValue('--player-color');
                    ctx.beginPath();
                    ctx.arc(
                        playerPosition.x * cellSize + cellSize / 2,
                        playerPosition.y * cellSize + cellSize / 2,
                        cellSize / 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }

                // ÈîÆÁõòÊéßÂà∂
                function handleKeyDown(e) {
                    if (gameState.isPaused || gameState.isGameOver) return;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            movePlayer(0, -1);
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            movePlayer(0, 1);
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            movePlayer(-1, 0);
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            movePlayer(1, 0);
                            break;
                    }
                }

                // ÁßªÂä®Áé©ÂÆ∂
                function movePlayer(dx, dy) {
                    if (gameState.isPaused || gameState.isGameOver) return;
                    
                    const { x, y } = gameState.playerPosition;
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    // Ê£ÄÊü•ËæπÁïåÂíåÂ¢ôÂ£Å
                    if (newX >= 0 && newX < gameState.mazeWidth && 
                        newY >= 0 && newY < gameState.mazeHeight && 
                        gameState.maze[newY][newX] === 0) {
                        
                        gameState.playerPosition = { x: newX, y: newY };
                        renderMaze();
                        
                        // Ê£ÄÊü•ÊòØÂê¶Âà∞ËææÁªàÁÇπ
                        if (newX === gameState.exitPosition.x && newY === gameState.exitPosition.y) {
                            levelCompleted();
                        }
                    }
                }

                // ÂÖ≥Âç°ÂÆåÊàê
                function levelCompleted() {
                    clearInterval(gameState.timerInterval);
                    gameState.isGameOver = true;
                    
                    // Êõ¥Êñ∞Âπ∂‰øùÂ≠òÊúÄ‰Ω≥Êó∂Èó¥
                    const currentTime = gameState.currentTime;
                    const bestTime = getBestTime(gameState.currentLevel);
                    
                    if (!bestTime || currentTime < bestTime) {
                        setBestTime(gameState.currentLevel, currentTime);
                    }
                    
                    // ÊòæÁ§∫ÂÆåÊàêÊïàÊûú
                    showParticles();
                    
                    // Ëá™Âä®Ëß£ÈîÅ‰∏ã‰∏ÄÂÖ≥
                    if (gameState.currentLevel === gameState.maxUnlockedLevel && 
                        gameState.currentLevel < levels.length) {
                        gameState.maxUnlockedLevel++;
                        storage.save('mazeGameProgress', {
                            maxUnlockedLevel: gameState.maxUnlockedLevel,
                            bestTimes: gameState.bestTimes
                        });
                        
                        // Êõ¥Êñ∞ÂÖ≥Âç°ÊåâÈíÆÁä∂ÊÄÅ
                        updateLevelButtons();
                        
                        // Âª∂ËøüÂêéËá™Âä®ËøõÂÖ•‰∏ã‰∏ÄÂÖ≥
                        if (gameState.currentLevel < levels.length) {
                            setTimeout(() => {
                                changeLevel(gameState.currentLevel + 1);
                            }, 1500);
                        } else {
                            setTimeout(() => {
                                alert('ÊÅ≠ÂñúÂÆåÊàêÊâÄÊúâÂÖ≥Âç°ÔºÅ');
                            }, 500);
                        }
                    }
                }

                // ÊòæÁ§∫Á≤íÂ≠êÊïàÊûú
                function showParticles() {
                    const particles = elements.particles;
                    particles.innerHTML = '';

                    const fragment = document.createDocumentFragment();
                    for (let i = 0; i < 50; i++) { // ÂáèÂ∞ëÁ≤íÂ≠êÊï∞Èáè
                        const particle = document.createElement('div');
                        particle.style.position = 'absolute';
                        particle.style.width = '5px';
                        particle.style.height = '5px';
                        particle.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                        particle.style.borderRadius = '50%';
                        particle.style.left = `${Math.random() * 100}%`;
                        particle.style.top = `${Math.random() * 100}%`;
                        particle.style.animation = `moveParticle ${Math.random() * 1 + 0.5}s forwards`;

                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 100 + 50;
                        const endX = 50 + Math.cos(angle) * distance;
                        const endY = 50 + Math.sin(angle) * distance;

                        const keyframes = `
                            @keyframes moveParticle {
                                to {
                                    transform: translate(${endX - 50}px, ${endY - 50}px);
                                    opacity: 0;
                                }
                            }
                        `;

                        const style = document.createElement('style');
                        style.innerHTML = keyframes;
                        document.head.appendChild(style);

                        fragment.appendChild(particle);
                    }
                    particles.appendChild(fragment);

                    setTimeout(() => {
                        particles.innerHTML = '';
                    }, 1000);
                }

                // ËÆ°Êó∂Âô®ÂäüËÉΩ
                function startTimer() {
                    gameState.startTime = Date.now();
                    gameState.currentTime = 0;
                    clearInterval(gameState.timerInterval);
                    
                    gameState.timerInterval = setInterval(() => {
                        if (!gameState.isPaused && !gameState.isGameOver) {
                            gameState.currentTime = Date.now() - gameState.startTime;
                            elements.timer.textContent = formatTime(gameState.currentTime);
                        }
                    }, 10);
                }

                // Ê†ºÂºèÂåñÊó∂Èó¥
                function formatTime(ms) {
                    const date = new Date(ms);
                    const minutes = date.getUTCMinutes().toString().padStart(2, '0');
                    const seconds = date.getUTCSeconds().toString().padStart(2, '0');
                    const milliseconds = Math.floor(date.getUTCMilliseconds() / 10).toString().padStart(2, '0');
                    return `${minutes}:${seconds}.${milliseconds}`;
                }

                // Ëé∑ÂèñÊúÄ‰Ω≥Êó∂Èó¥
                function getBestTime(level) {
                    try {
                        const bestTimesStr = localStorage.getItem('mazeBestTimes');
                        if (!bestTimesStr) return null;
                        const bestTimes = JSON.parse(bestTimesStr);
                        return bestTimes[level] || null;
                    } catch (error) {
                        console.error('Ëé∑ÂèñÊúÄ‰Ω≥Êó∂Èó¥Â§±Ë¥•:', error);
                        return null;
                    }
                }

                // ËÆæÁΩÆÊúÄ‰Ω≥Êó∂Èó¥
                function setBestTime(level, time) {
                    try {
                        const bestTimesStr = localStorage.getItem('mazeBestTimes');
                        const bestTimes = bestTimesStr ? JSON.parse(bestTimesStr) : {};
                        bestTimes[level] = time;
                        localStorage.setItem('mazeBestTimes', JSON.stringify(bestTimes));
                    } catch (error) {
                        console.error('‰øùÂ≠òÊúÄ‰Ω≥Êó∂Èó¥Â§±Ë¥•:', error);
                    }
                }

                // ÂàáÊç¢ÊöÇÂÅúÁä∂ÊÄÅ
                function togglePause() {
                    gameState.isPaused = !gameState.isPaused;
                    elements.pauseBtn.textContent = gameState.isPaused ? 'ÁªßÁª≠' : 'ÊöÇÂÅú';
                    
                    if (gameState.isPaused) {
                        clearInterval(gameState.timerInterval);
                    } else {
                        gameState.startTime = Date.now() - gameState.currentTime;
                        startTimer();
                    }
                }

                // ÈáçÊñ∞ÂºÄÂßãÂΩìÂâçÂÖ≥Âç°
                function restartLevel() {
                    gameState.isPaused = false;
                    gameState.isGameOver = false;
                    elements.pauseBtn.textContent = 'ÊöÇÂÅú';
                    generateMaze(levels[gameState.currentLevel - 1]);
                    startTimer();
                    renderMaze();
                }

                // ÂàáÊç¢ÂÖ≥Âç°
                function changeLevel(level) {
                    if (level < 1 || level > levels.length) return;
                    
                    gameState.currentLevel = level;
                    gameState.isPaused = false;
                    gameState.isGameOver = false;
                    elements.pauseBtn.textContent = 'ÊöÇÂÅú';
                    elements.currentLevel.textContent = level;
                    
                    generateMaze(levels[level - 1]);
                    startTimer();
                    renderMaze();
                }

                // Êõ¥Êñ∞ÂÖ≥Âç°ÊåâÈíÆÁä∂ÊÄÅ
                function updateLevelButtons() {
                    elements.levelBtns.forEach(btn => {
                        const level = parseInt(btn.dataset.level);
                        btn.disabled = level > gameState.maxUnlockedLevel;
                    });
                }

                // ÂàáÊç¢ÊèêÁ§∫ÊòæÁ§∫
                function toggleHint() {
                    gameState.showHint = !gameState.showHint;
                    elements.hintBtn.textContent = gameState.showHint ? 'ÊÅ¢Â§ç' : 'ÊèêÁ§∫';
                    renderMaze();
                }

                // ÁîüÊàêÊèêÁ§∫Ë∑ØÂæÑ (‰ΩøÁî®A*ÁÆóÊ≥ï)
                function generateHintPath() {
                    const { maze, playerPosition, exitPosition } = gameState;
                    const openSet = [];
                    const closedSet = [];
                    const path = [];
                    
                    // ÁÆÄÂåñÁâàÁöÑË∑ØÂæÑÊü•Êâæ - ÂÆûÈôÖÂ∫îÁî®‰∏≠ÂèØ‰ª•‰ΩøÁî®Êõ¥Â§çÊùÇÁöÑÁÆóÊ≥ïÂ¶ÇA*
                    // ËøôÈáå‰ΩøÁî®‰∏Ä‰∏™ÁÆÄÂåñÁöÑBFSÂÆûÁé∞
                    const queue = [{ x: playerPosition.x, y: playerPosition.y, path: [] }];
                    const visited = Array(maze.length).fill().map(() => 
                        Array(maze[0].length).fill(false)
                    );
                    
                    visited[playerPosition.y][playerPosition.x] = true;
                    
                    const directions = [
                        [1, 0], [-1, 0], [0, 1], [0, -1]
                    ];
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        
                        if (current.x === exitPosition.x && current.y === exitPosition.y) {
                            gameState.hintPath = current.path;
                            return;
                        }
                        
                        for (const [dx, dy] of directions) {
                            const nx = current.x + dx;
                            const ny = current.y + dy;
                            
                            if (nx >= 0 && nx < maze[0].length && 
                                ny >= 0 && ny < maze.length && 
                                maze[ny][nx] === 0 && !visited[ny][nx]) {
                                
                                visited[ny][nx] = true;
                                queue.push({ 
                                    x: nx, 
                                    y: ny, 
                                    path: [...current.path, { x: nx, y: ny }] 
                                });
                            }
                        }
                    }
                    
                    gameState.hintPath = [];
                }

                // Á™óÂè£Â§ßÂ∞èÊîπÂèòÊó∂ÈáçÊñ∞ËÆ°ÁÆó
                window.addEventListener('resize', () => {
                    try {
                        calculateCellSize();
                        renderMaze();
                    } catch (error) {
                        console.error('Á™óÂè£Â§ßÂ∞èÂèòÂåñÂ§ÑÁêÜÂ§±Ë¥•Ôºö', error);
                    }
                });

                // ÂàùÂßãÂåñÊ∏∏Êàè
                initGame();
            } catch (error) {
                console.error('Ê∏∏ÊàèÂêØÂä®Â§±Ë¥•:', error);
                alert('Ê∏∏ÊàèÂêØÂä®Â§±Ë¥•ÔºåËØ∑Âà∑Êñ∞È°µÈù¢ÈáçËØï');
            }
        });
    </script>
</body>
</html>

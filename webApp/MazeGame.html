<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¿·å®«æ¢é™©</title>
    <style>
        :root {
            --wall-color: #2c3e50;
            --path-color: #ecf0f1;
            --player-color: #e74c3c;
            --exit-color: #2ecc71;
            --text-color: #2c3e50;
            --bg-color: #bdc3c7;
            --button-color: #3498db;
            --button-hover: #2980b9;
        }

        body {
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.3s;
        }

        .dark-mode {
            --wall-color: #34495e;
            --path-color: #2c3e50;
            --player-color: #e74c3c;
            --exit-color: #27ae60;
            --text-color: #ecf0f1;
            --bg-color: #2c3e50;
            --button-color: #3498db;
            --button-hover: #2980b9;
        }

        header {
            width: 100%;
            background-color: var(--wall-color);
            color: white;
            padding:  1rem 0 5px 0;
            text-align: center;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 5px auto;
            width: 100%;
            max-width: 800px;
        }

        .controls {
            display: flex;
            justify-content: space-between;
            width: 100%;
            margin-bottom: 1rem;
            flex-wrap: wrap;
        }

        .timer {
            font-size: 1.5rem;
            font-weight: bold;
            background-color: var(--wall-color);
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        .buttons {
            display: flex;
            gap: 1rem;
        }

        button {
            background-color: var(--button-color);
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }

        button:hover {
            background-color: var(--button-hover);
        }

        button:disabled {
            background-color: #95a5a6;
            cursor: not-allowed;
        }

        .maze-container {
            position: relative;
            width: 100%;
            max-width: 600px;
            aspect-ratio: 1/1;
            background-color: var(--wall-color);
            border: 2px solid var(--wall-color);
            box-shadow: 0 4px 10px rgba(0,0,0,0.3);
            overflow: hidden;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .level-info {
            margin-top: 1rem;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .level-select {
            margin-top: 1rem;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 0.5rem;
        }

        .level-btn {
            min-width: 40px;
        }

        .mobile-controls {
            display: none;
            margin-top: 1rem;
            width: 100%;
            max-width: 300px;
        }

        .mobile-controls-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            gap: 5px;
            width: 100%;
            aspect-ratio: 1/1;
        }

        .mobile-btn {
            background-color: var(--button-color);
            color: white;
            border: none;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            user-select: none;
        }

        .mobile-btn:active {
            background-color: var(--button-hover);
        }

        .up { grid-area: 1 / 2; }
        .left { grid-area: 2 / 1; }
        .center { grid-area: 2 / 2; background-color: transparent; }
        .right { grid-area: 2 / 3; }
        .down { grid-area: 3 / 2; }

        .particles {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .theme-toggle {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background-color: var(--button-color);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 100;
        }

        @media (max-width: 768px) {
            .mobile-controls {
                display: block;
            }
            
            .controls {
                flex-direction: column;
                align-items: center;
                gap: 1rem;
            }
            
            .buttons {
                width: 100%;
                justify-content: center;
            }
        }
    </style>
</head>
<body>
    <header>
        <h1>è¿·å®«æ¢é™©</h1>
    </header>

    <div class="game-container">
        <div class="controls">
            <div class="timer">00:00.00</div>
            <div class="buttons">
                <button id="pauseBtn">æš‚åœ</button>
                <button id="restartBtn">é‡ç½®</button>
                <button id="hintBtn">æç¤º</button>
            </div>
        </div>

        <div class="maze-container">
            <canvas id="mazeCanvas"></canvas>
            <div class="particles" id="particles"></div>
        </div>

        <div class="level-info">éš¾åº¦: <span id="currentLevel">1</span>/5</div>

        <div class="level-select">
            <button class="level-btn" data-level="1">1</button>
            <button class="level-btn" data-level="2">2</button>
            <button class="level-btn" data-level="3">3</button>
            <button class="level-btn" data-level="4">4</button>
            <button class="level-btn" data-level="5">5</button>
        </div>

        <div class="mobile-controls">
            <div class="mobile-controls-grid">
                <button class="mobile-btn up">â†‘</button>
                <button class="mobile-btn left">â†</button>
                <div class="center"></div>
                <button class="mobile-btn right">â†’</button>
                <button class="mobile-btn down">â†“</button>
            </div>
        </div>
    </div>

    <div class="theme-toggle" id="themeToggle">ğŸŒ“</div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // æ¸¸æˆçŠ¶æ€
            const gameState = {
                currentLevel: 1,
                maxUnlockedLevel: 1,
                isPaused: false,
                isGameOver: false,
                startTime: 0,
                currentTime: 0,
                timerInterval: null,
                playerPosition: { x: 1, y: 1 },
                exitPosition: { x: 0, y: 0 },
                maze: [],
                mazeWidth: 10,
                mazeHeight: 10,
                cellSize: 0,
                hintPath: [],
                showHint: false,
                bestTimes: {}
            };

            // åˆå§‹åŒ–æ¸¸æˆ
            try {
                const canvas = document.getElementById('mazeCanvas');
                const ctx = canvas?.getContext('2d');

                if (!canvas || !ctx) {
                    throw new Error('Canvas æˆ–ä¸Šä¸‹æ–‡æœªæ­£ç¡®åˆå§‹åŒ–ã€‚');
                }

                // DOM å…ƒç´ 
                const elements = {
                    canvas,
                    ctx,
                    timer: document.querySelector('.timer'),
                    currentLevel: document.getElementById('currentLevel'),
                    pauseBtn: document.getElementById('pauseBtn'),
                    restartBtn: document.getElementById('restartBtn'),
                    hintBtn: document.getElementById('hintBtn'),
                    levelBtns: document.querySelectorAll('.level-btn'),
                    mobileBtns: document.querySelectorAll('.mobile-btn'),
                    particles: document.getElementById('particles'),
                    themeToggle: document.getElementById('themeToggle'),
                    body: document.body
                };

                // å…³å¡é…ç½®
                const levels = [
                    { width: 15, height: 15, complexity: 0.1, density: 0.15 }, // Level 1
                    { width: 19, height: 19, complexity: 0.2, density: 0.15 }, // Level 2
                    { width: 25, height: 25, complexity: 0.3, density: 0.2 },  // Level 3
                    { width: 31, height: 31, complexity: 0.4, density: 0.2 }, // Level 4
                    { width: 37, height: 37, complexity: 0.5, density: 0.3 }   // Level 5
                ];

                // ä¼˜åŒ–çš„è¿·å®«ç”Ÿæˆå‡½æ•°
                function generateMaze(levelConfig) {
                    const maxAttempts = 6;
                    let attempts = 0;
                    
                    while (attempts < maxAttempts) {
                        try {
                            gameState.mazeWidth = levelConfig.width;
                            gameState.mazeHeight = levelConfig.height;
                            gameState.maze = Array(gameState.mazeHeight).fill().map(() => Array(gameState.mazeWidth).fill(1));
                            gameState.playerPosition = { x: 1, y: 1 };
                            gameState.exitPosition = { x: gameState.mazeWidth - 2, y: gameState.mazeHeight - 2 };
                            
                            // ä½¿ç”¨æ”¹è¿›åçš„DFSç”Ÿæˆè¿·å®«
                            dfsGenerate(1, 1);
                            
                            // ç¡®ä¿èµ·ç‚¹å’Œç»ˆç‚¹ä¸ºè·¯å¾„
                            gameState.maze[1][1] = 0;
                            gameState.maze[gameState.exitPosition.y][gameState.exitPosition.x] = 0;
                            
                            // éªŒè¯è¿·å®«æ˜¯å¦æœ‰å¯è¾¾è·¯å¾„
                            if (validatePath()) {
                                calculateCellSize();
                                generateHintPath();
                                return true;
                            }
                        } catch (error) {
                            console.warn(`è¿·å®«ç”Ÿæˆå°è¯• ${attempts + 1} å¤±è´¥:`, error);
                        }
                        attempts++;
                    }
                    throw new Error('æ— æ³•ç”Ÿæˆæœ‰æ•ˆè¿·å®«ï¼Œè¯·é‡è¯•');
                }

                // æ”¹è¿›çš„DFSç”Ÿæˆç®—æ³•
                function dfsGenerate(x, y) {
                    const directions = [
                        [2, 0], [-2, 0], [0, 2], [0, -2]
                    ].sort(() => Math.random() - 0.5);
                    
                    gameState.maze[y][x] = 0;
                    
                    for (const [dx, dy] of directions) {
                        const nextX = x + dx;
                        const nextY = y + dy;
                        const wallX = x + dx/2;
                        const wallY = y + dy/2;
                        
                        if (isValidCell(nextX, nextY) && gameState.maze[nextY][nextX] === 1) {
                            gameState.maze[wallY][wallX] = 0;
                            dfsGenerate(nextX, nextY);
                        }
                    }
                }

                // éªŒè¯è·¯å¾„æ˜¯å¦å¯è¾¾
                function validatePath() {
                    const visited = Array(gameState.mazeHeight).fill().map(() => Array(gameState.mazeWidth).fill(false));
                    const queue = [{...gameState.playerPosition}];
                    visited[gameState.playerPosition.y][gameState.playerPosition.x] = true;
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        
                        if (current.x === gameState.exitPosition.x && current.y === gameState.exitPosition.y) {
                            return true;
                        }
                        
                        for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                            const nx = current.x + dx;
                            const ny = current.y + dy;
                            
                            if (isValidCell(nx, ny) && gameState.maze[ny][nx] === 0 && !visited[ny][nx]) {
                                visited[ny][nx] = true;
                                queue.push({x: nx, y: ny});
                            }
                        }
                    }
                    return false;
                }

                // åˆå§‹åŒ–è¿·å®«ç½‘æ ¼
                function initializeMazeGrid(levelConfig) {
                    gameState.mazeWidth = levelConfig.width;
                    gameState.mazeHeight = levelConfig.height;
                    gameState.maze = Array(gameState.mazeHeight).fill().map(() => 
                        Array(gameState.mazeWidth).fill(1)
                    );
                    gameState.playerPosition = { x: 1, y: 1 };
                    gameState.exitPosition = { 
                        x: gameState.mazeWidth - 2, 
                        y: gameState.mazeHeight - 2 
                    };
                }

                // ä½¿ç”¨DFSç®—æ³•é›•åˆ»è¿·å®«è·¯å¾„
                function carvePathsByDFS(x, y) {
                    const directions = [
                        [2, 0], [-2, 0], [0, 2], [0, -2]
                    ];
                    
                    // éšæœºæ‰“ä¹±æ–¹å‘
                    directions.sort(() => Math.random() - 0.5);
                    
                    gameState.maze[y][x] = 0;
                    
                    for (const [dx, dy] of directions) {
                        const nextX = x + dx;
                        const nextY = y + dy;
                        const wallX = x + dx/2;
                        const wallY = y + dy/2;
                        
                        if (isValidCell(nextX, nextY) && gameState.maze[nextY][nextX] === 1) {
                            gameState.maze[wallY][wallX] = 0; // æ‰“é€šå¢™å£
                            carvePathsByDFS(nextX, nextY);
                        }
                    }
                }

                // ç¡®ä¿èµ·ç‚¹å’Œç»ˆç‚¹å¯ç”¨
                function ensureStartAndEnd() {
                    const { playerPosition, exitPosition } = gameState;
                    
                    gameState.maze[playerPosition.y][playerPosition.x] = 0;
                    gameState.maze[exitPosition.y][exitPosition.x] = 0;
                    
                    // ç¡®ä¿èµ·ç‚¹å’Œç»ˆç‚¹å‘¨å›´æœ‰è·¯
                    for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                        const startX = playerPosition.x + dx;
                        const startY = playerPosition.y + dy;
                        const endX = exitPosition.x + dx;
                        const endY = exitPosition.y + dy;
                        
                        if (isValidCell(startX, startY)) {
                            gameState.maze[startY][startX] = 0;
                        }
                        if (isValidCell(endX, endY)) {
                            gameState.maze[endY][endX] = 0;
                        }
                    }
                }

                // éªŒè¯è¿·å®«æ˜¯å¦æœ‰æ•ˆ
                function validateMaze() {
                    const visited = Array(gameState.mazeHeight).fill().map(() => 
                        Array(gameState.mazeWidth).fill(false)
                    );
                    
                    const queue = [gameState.playerPosition];
                    visited[gameState.playerPosition.y][gameState.playerPosition.x] = true;
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        
                        if (current.x === gameState.exitPosition.x && 
                            current.y === gameState.exitPosition.y) {
                            return true;
                        }
                        
                        for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                            const nx = current.x + dx;
                            const ny = current.y + dy;
                            
                            if (isValidCell(nx, ny) && 
                                gameState.maze[ny][nx] === 0 && 
                                !visited[ny][nx]) {
                                visited[ny][nx] = true;
                                queue.push({ x: nx, y: ny });
                            }
                        }
                    }
                    
                    return false;
                }

                // æ£€æŸ¥å•å…ƒæ ¼æ˜¯å¦æœ‰æ•ˆ
                function isValidCell(x, y) {
                    return x > 0 && x < gameState.mazeWidth - 1 && 
                           y > 0 && y < gameState.mazeHeight - 1;
                }

                // ç®€åŒ–çš„å­˜å‚¨ç®¡ç†
                const storage = {
                    save: (key, data) => {
                        try {
                            localStorage.setItem(key, JSON.stringify(data));
                        } catch (error) {
                            console.error('å­˜å‚¨æ•°æ®å¤±è´¥:', error);
                        }
                    },
                    load: (key, defaultValue = null) => {
                        try {
                            const data = localStorage.getItem(key);
                            return data ? JSON.parse(data) : defaultValue;
                        } catch (error) {
                            console.error('è¯»å–æ•°æ®å¤±è´¥:', error);
                            return defaultValue;
                        }
                    }
                };

                // è¿·å®«ç”Ÿæˆå™¨ç±»
                class MazeGenerator {
                    constructor(width, height) {
                        this.width = width;
                        this.height = height;
                        this.maze = Array(height).fill().map(() => Array(width).fill(1));
                    }
                
                    // ç”Ÿæˆè¿·å®«
                    generate() {
                        // åˆå§‹åŒ–èµ·ç‚¹å’Œç»ˆç‚¹
                        const start = { x: 1, y: 1 };
                        const end = { x: this.width - 2, y: this.height - 2 };
                
                        // æ¸…ç©ºèµ·ç‚¹å’Œç»ˆç‚¹
                        this.maze[start.y][start.x] = 0;
                        this.maze[end.y][end.x] = 0;
                
                        // ä»èµ·ç‚¹å¼€å§‹ç”Ÿæˆè¿·å®«
                        this.carvePassages(start.x, start.y);
                        
                        // ç¡®ä¿ç»ˆç‚¹å¯è¾¾
                        this.ensureEndReachable(end.x, end.y);
                        
                        return this.maze;
                    }
                
                    // é›•åˆ»é€šé“
                    carvePassages(x, y) {
                        const directions = [
                            [0, -2], [2, 0], [0, 2], [-2, 0]
                        ].sort(() => Math.random() - 0.5);
                
                        for (const [dx, dy] of directions) {
                            const nx = x + dx;
                            const ny = y + dy;
                
                            if (this.isInBounds(nx, ny) && this.maze[ny][nx] === 1) {
                                this.maze[y + dy/2][x + dx/2] = 0;
                                this.maze[ny][nx] = 0;
                                this.carvePassages(nx, ny);
                            }
                        }
                    }
                
                    // ç¡®ä¿ç»ˆç‚¹å¯è¾¾
                    ensureEndReachable(endX, endY) {
                        // å¦‚æœæ— æ³•åˆ°è¾¾ç»ˆç‚¹ï¼Œåˆ›å»ºä¸€æ¡ç›´æ¥é€šé“
                        if (!this.pathExists({ x: 1, y: 1 }, { x: endX, y: endY })) {
                            let x = endX, y = endY;
                            while (x > 1 || y > 1) {
                                this.maze[y][x] = 0;
                                if (x > 1) x--;
                                if (y > 1) y--;
                                this.maze[y][x] = 0;
                            }
                        }
                    }
                
                    // æ£€æŸ¥è·¯å¾„æ˜¯å¦å­˜åœ¨
                    pathExists(start, end) {
                        const visited = Array(this.height).fill().map(() => Array(this.width).fill(false));
                        const queue = [start];
                        visited[start.y][start.x] = true;
                
                        while (queue.length > 0) {
                            const current = queue.shift();
                            if (current.x === end.x && current.y === end.y) return true;
                
                            for (const [dx, dy] of [[0, 1], [1, 0], [0, -1], [-1, 0]]) {
                                const nx = current.x + dx;
                                const ny = current.y + dy;
                                if (this.isInBounds(nx, ny) && this.maze[ny][nx] === 0 && !visited[ny][nx]) {
                                    visited[ny][nx] = true;
                                    queue.push({ x: nx, y: ny });
                                }
                            }
                        }
                        return false;
                    }
                
                    // æ£€æŸ¥åæ ‡æ˜¯å¦åœ¨è¿·å®«èŒƒå›´å†…
                    isInBounds(x, y) {
                        return x > 0 && x < this.width - 1 && y > 0 && y < this.height - 1;
                    }
                }
                
                // åˆå§‹åŒ–æ¸¸æˆ
                function initGame() {
                    try {
                        // åŠ è½½æ¸¸æˆè¿›åº¦
                        const savedProgress = storage.load('mazeGameProgress', { maxUnlockedLevel: 1, bestTimes: {} });
                        gameState.maxUnlockedLevel = savedProgress.maxUnlockedLevel;
                        gameState.bestTimes = savedProgress.bestTimes;
                
                        // è®¾ç½®äº‹ä»¶ç›‘å¬
                        setupEventListeners();
                
                        // ç”Ÿæˆåˆå§‹è¿·å®«
                        const level = levels[gameState.currentLevel - 1];
                        const generator = new MazeGenerator(level.width, level.height);
                        gameState.maze = generator.generate();
                        gameState.mazeWidth = level.width;
                        gameState.mazeHeight = level.height;
                        
                        // åˆå§‹åŒ–çŠ¶æ€
                        gameState.playerPosition = { x: 1, y: 1 };
                        gameState.exitPosition = { x: level.width - 2, y: level.height - 2 };

                        //åˆå§‹å¿…é‡ç½®ä¸€æ¬¡è¿·å®«
                        restartLevel();
                
                        // æ›´æ–°æ˜¾ç¤º
                        calculateCellSize();
                        generateHintPath();
                        startTimer();
                        renderMaze();
                        updateLevelButtons();
                    } catch (error) {
                        console.error('æ¸¸æˆåˆå§‹åŒ–å¤±è´¥:', error);
                        alert('è¿·å®«ç”Ÿæˆå¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                    }
                }
                
                // ä¿®æ”¹é‡æ–°å¼€å§‹å…³å¡å‡½æ•°
                function restartLevel() {
                    try {
                        gameState.isPaused = false;
                        gameState.isGameOver = false;
                        elements.pauseBtn.textContent = 'æš‚åœ';
                
                        const level = levels[gameState.currentLevel - 1];
                        const generator = new MazeGenerator(level.width, level.height);
                        gameState.maze = generator.generate();
                        gameState.playerPosition = { x: 1, y: 1 };
                        
                        startTimer();
                        renderMaze();
                    } catch (error) {
                        console.error('é‡æ–°å¼€å§‹å…³å¡å¤±è´¥:', error);
                        alert('è¿·å®«ç”Ÿæˆå¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                    }
                }
                
                // ä¿®æ”¹åˆ‡æ¢å…³å¡å‡½æ•°
                function changeLevel(level) {
                    if (level < 1 || level > levels.length) return;
                    
                    try {
                        gameState.currentLevel = level;
                        gameState.isPaused = false;
                        gameState.isGameOver = false;
                        elements.pauseBtn.textContent = 'æš‚åœ';
                        elements.currentLevel.textContent = level;
                
                        const levelConfig = levels[level - 1];
                        const generator = new MazeGenerator(levelConfig.width, levelConfig.height);
                        gameState.maze = generator.generate();
                        gameState.mazeWidth = levelConfig.width;
                        gameState.mazeHeight = levelConfig.height;
                        gameState.playerPosition = { x: 1, y: 1 };
                        gameState.exitPosition = { x: levelConfig.width - 2, y: levelConfig.height - 2 };
                
                        calculateCellSize();
                        generateHintPath();
                        startTimer();
                        renderMaze();
                    } catch (error) {
                        console.error('åˆ‡æ¢å…³å¡å¤±è´¥:', error);
                        alert('è¿·å®«ç”Ÿæˆå¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                    }
                }

                // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
                function setupEventListeners() {
                    // é”®ç›˜æ§åˆ¶
                    document.addEventListener('keydown', handleKeyDown);
                    
                    // æŒ‰é’®äº‹ä»¶
                    elements.pauseBtn.addEventListener('click', togglePause);
                    elements.restartBtn.addEventListener('click', restartLevel);
                    elements.hintBtn.addEventListener('click', toggleHint);
                    
                    // å…³å¡é€‰æ‹©
                    elements.levelBtns.forEach(btn => {
                        btn.addEventListener('click', () => {
                            const level = parseInt(btn.dataset.level);
                            if (level <= gameState.maxUnlockedLevel) {
                                changeLevel(level);
                            }
                        });
                    });
                    
                    // ç§»åŠ¨ç«¯æ§åˆ¶
                    elements.mobileBtns.forEach(btn => {
                        btn.addEventListener('click', () => {
                            if (btn.textContent === 'â†‘') movePlayer(0, -1);
                            if (btn.textContent === 'â†“') movePlayer(0, 1);
                            if (btn.textContent === 'â†') movePlayer(-1, 0);
                            if (btn.textContent === 'â†’') movePlayer(1, 0);
                        });
                    });
                    
                    // ä¸»é¢˜åˆ‡æ¢
                    elements.themeToggle.addEventListener('click', toggleTheme);
                }

                // åˆ‡æ¢ä¸»é¢˜
                function toggleTheme() {
                    elements.body.classList.toggle('dark-mode');
                    renderMaze();
                }

                // ç”Ÿæˆè¿·å®« (ä½¿ç”¨æ·±åº¦ä¼˜å…ˆæœç´¢ç®—æ³•)
                function generateMaze(levelConfig) {
                    gameState.mazeWidth = levelConfig.width;
                    gameState.mazeHeight = levelConfig.height;
                    gameState.maze = Array(gameState.mazeHeight).fill().map(() => Array(gameState.mazeWidth).fill(1));
                    gameState.playerPosition = { x: 1, y: 1 };
                    gameState.exitPosition = { x: gameState.mazeWidth - 2, y: gameState.mazeHeight - 2 };
                    dfsGenerate(1, 1, levelConfig.complexity, levelConfig.density);
                    gameState.maze[1][1] = 0;
                    gameState.maze[gameState.exitPosition.y][gameState.exitPosition.x] = 0;

                    // å¦‚æœè·¯å¾„ä¸å¯è¾¾ï¼Œåˆ™å¼ºåˆ¶è¿æ¥èµ·ç‚¹å’Œç»ˆç‚¹
                    if (!ensurePath()) {
                        forceConnectPath();
                    }

                    calculateCellSize();
                    generateHintPath();
                }

                // æ–°å¢ï¼šå¼ºåˆ¶è¿æ¥èµ·ç‚¹å’Œç»ˆç‚¹çš„å‡½æ•°
                function forceConnectPath() {
                    let { x: curX, y: curY } = gameState.playerPosition;
                    const { x: exitX, y: exitY } = gameState.exitPosition;

                    // æ¨ªå‘è¿æ¥
                    while (curX !== exitX) {
                        gameState.maze[curY][curX] = 0;
                        curX += exitX > curX ? 1 : -1;
                    }

                    // çºµå‘è¿æ¥
                    while (curY !== exitY) {
                        gameState.maze[curY][curX] = 0;
                        curY += exitY > curY ? 1 : -1;
                    }
                }

                // æ·±åº¦ä¼˜å…ˆæœç´¢ç”Ÿæˆè¿·å®«
                function dfsGenerate(x, y, complexity, density) {
                    const directions = [
                        [1, 0], [-1, 0], [0, 1], [0, -1]
                    ].sort(() => Math.random() - 0.5);
                    
                    gameState.maze[y][x] = 0;
                    
                    for (const [dx, dy] of directions) {
                        const nx = x + dx * 2;
                        const ny = y + dy * 2;
                        
                        if (nx > 0 && nx < gameState.mazeWidth - 1 && 
                            ny > 0 && ny < gameState.mazeHeight - 1 && 
                            gameState.maze[ny][nx] === 1) {
                            
                            gameState.maze[y + dy][x + dx] = 0;
                            dfsGenerate(nx, ny, complexity, density);
                        }
                    }
                }

                // ç¡®ä¿è¿·å®«æœ‰é€šè·¯
                function ensurePath() {
                    const { maze, playerPosition, exitPosition } = gameState;
                    const visited = Array(maze.length).fill().map(() => Array(maze[0].length).fill(false));
                    const stack = [playerPosition];
                    visited[playerPosition.y][playerPosition.x] = true;

                    while (stack.length > 0) {
                        const { x, y } = stack.pop();
                        if (x === exitPosition.x && y === exitPosition.y) return true;

                        for (const [dx, dy] of [[1, 0], [-1, 0], [0, 1], [0, -1]]) {
                            const nx = x + dx;
                            const ny = y + dy;

                            if (nx >= 0 && nx < maze[0].length && ny >= 0 && ny < maze.length &&
                                maze[ny][nx] === 0 && !visited[ny][nx]) {
                                visited[ny][nx] = true;
                                stack.push({ x: nx, y: ny });
                            }
                        }
                    }
                    return false;
                }

                // è®¡ç®—å•å…ƒæ ¼å¤§å°
                function calculateCellSize() {
                    const container = document.querySelector('.maze-container');
                    const containerWidth = container.clientWidth;
                    const containerHeight = container.clientHeight;
                    
                    gameState.cellSize = Math.min(
                        containerWidth / gameState.mazeWidth,
                        containerHeight / gameState.mazeHeight
                    );
                    
                    elements.canvas.width = gameState.mazeWidth * gameState.cellSize;
                    elements.canvas.height = gameState.mazeHeight * gameState.cellSize;
                }

                // æ¸²æŸ“è¿·å®«
                function renderMaze() {
                    const { ctx, canvas } = elements;
                    const { maze, cellSize, playerPosition, exitPosition } = gameState;
                    
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    
                    // ç»˜åˆ¶è¿·å®«
                    for (let y = 0; y < maze.length; y++) {
                        for (let x = 0; x < maze[y].length; x++) {
                            if (maze[y][x] === 1) {
                                // å¢™å£
                                ctx.fillStyle = getComputedStyle(document.documentElement)
                                    .getPropertyValue('--wall-color');
                                
                                // æ·»åŠ 3Dæ•ˆæœ
                                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                                ctx.shadowBlur = 2;
                                ctx.shadowOffsetX = 2;
                                ctx.shadowOffsetY = 2;
                                
                                ctx.fillRect(
                                    x * cellSize, 
                                    y * cellSize, 
                                    cellSize, 
                                    cellSize
                                );
                                
                                // é‡ç½®é˜´å½±
                                ctx.shadowColor = 'transparent';
                            } else {
                                // è·¯å¾„
                                ctx.fillStyle = getComputedStyle(document.documentElement)
                                    .getPropertyValue('--path-color');
                                ctx.fillRect(
                                    x * cellSize, 
                                    y * cellSize, 
                                    cellSize, 
                                    cellSize
                                );
                            }
                        }
                    }
                    
                    // ç»˜åˆ¶æç¤ºè·¯å¾„
                    if (gameState.showHint && gameState.hintPath.length > 0) {
                        ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                        for (const {x, y} of gameState.hintPath) {
                            ctx.fillRect(
                                x * cellSize + cellSize * 0.25,
                                y * cellSize + cellSize * 0.25,
                                cellSize * 0.5,
                                cellSize * 0.5
                            );
                        }
                    }
                    
                    // ç»˜åˆ¶å‡ºå£
                    ctx.fillStyle = getComputedStyle(document.documentElement)
                        .getPropertyValue('--exit-color');
                    ctx.beginPath();
                    ctx.arc(
                        exitPosition.x * cellSize + cellSize / 2,
                        exitPosition.y * cellSize + cellSize / 2,
                        cellSize / 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                    
                    // ç»˜åˆ¶ç©å®¶
                    ctx.fillStyle = getComputedStyle(document.documentElement)
                        .getPropertyValue('--player-color');
                    ctx.beginPath();
                    ctx.arc(
                        playerPosition.x * cellSize + cellSize / 2,
                        playerPosition.y * cellSize + cellSize / 2,
                        cellSize / 3,
                        0,
                        Math.PI * 2
                    );
                    ctx.fill();
                }

                // é”®ç›˜æ§åˆ¶
                function handleKeyDown(e) {
                    if (gameState.isPaused || gameState.isGameOver) return;
                    
                    switch(e.key) {
                        case 'ArrowUp':
                        case 'w':
                        case 'W':
                            movePlayer(0, -1);
                            break;
                        case 'ArrowDown':
                        case 's':
                        case 'S':
                            movePlayer(0, 1);
                            break;
                        case 'ArrowLeft':
                        case 'a':
                        case 'A':
                            movePlayer(-1, 0);
                            break;
                        case 'ArrowRight':
                        case 'd':
                        case 'D':
                            movePlayer(1, 0);
                            break;
                    }
                }

                // ç§»åŠ¨ç©å®¶
                function movePlayer(dx, dy) {
                    if (gameState.isPaused || gameState.isGameOver) return;
                    
                    const { x, y } = gameState.playerPosition;
                    const newX = x + dx;
                    const newY = y + dy;
                    
                    // æ£€æŸ¥è¾¹ç•Œå’Œå¢™å£
                    if (newX >= 0 && newX < gameState.mazeWidth && 
                        newY >= 0 && newY < gameState.mazeHeight && 
                        gameState.maze[newY][newX] === 0) {
                        
                        gameState.playerPosition = { x: newX, y: newY };
                        renderMaze();
                        
                        // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾ç»ˆç‚¹
                        if (newX === gameState.exitPosition.x && newY === gameState.exitPosition.y) {
                            levelCompleted();
                        }
                    }
                }

                // å…³å¡å®Œæˆ
                function levelCompleted() {
                    clearInterval(gameState.timerInterval);
                    gameState.isGameOver = true;
                    
                    // æ›´æ–°å¹¶ä¿å­˜æœ€ä½³æ—¶é—´
                    const currentTime = gameState.currentTime;
                    const bestTime = getBestTime(gameState.currentLevel);
                    
                    if (!bestTime || currentTime < bestTime) {
                        setBestTime(gameState.currentLevel, currentTime);
                    }
                    
                    // æ˜¾ç¤ºå®Œæˆæ•ˆæœ
                    showParticles();
                    
                    // è‡ªåŠ¨è§£é”ä¸‹ä¸€å…³
                    if (gameState.currentLevel === gameState.maxUnlockedLevel && 
                        gameState.currentLevel < levels.length) {
                        gameState.maxUnlockedLevel++;
                        storage.save('mazeGameProgress', {
                            maxUnlockedLevel: gameState.maxUnlockedLevel,
                            bestTimes: gameState.bestTimes
                        });
                        
                        // æ›´æ–°å…³å¡æŒ‰é’®çŠ¶æ€
                        updateLevelButtons();
                        
                        // å»¶è¿Ÿåè‡ªåŠ¨è¿›å…¥ä¸‹ä¸€å…³
                        if (gameState.currentLevel < levels.length) {
                            setTimeout(() => {
                                changeLevel(gameState.currentLevel + 1);
                            }, 1500);
                        } else {
                            setTimeout(() => {
                                alert('æ­å–œå®Œæˆæ‰€æœ‰å…³å¡ï¼');
                            }, 500);
                        }
                    }
                }

                // æ˜¾ç¤ºç²’å­æ•ˆæœ
                function showParticles() {
                    const particles = elements.particles;
                    particles.innerHTML = '';

                    const fragment = document.createDocumentFragment();
                    for (let i = 0; i < 50; i++) { // å‡å°‘ç²’å­æ•°é‡
                        const particle = document.createElement('div');
                        particle.style.position = 'absolute';
                        particle.style.width = '5px';
                        particle.style.height = '5px';
                        particle.style.backgroundColor = `hsl(${Math.random() * 360}, 100%, 50%)`;
                        particle.style.borderRadius = '50%';
                        particle.style.left = `${Math.random() * 100}%`;
                        particle.style.top = `${Math.random() * 100}%`;
                        particle.style.animation = `moveParticle ${Math.random() * 1 + 0.5}s forwards`;

                        const angle = Math.random() * Math.PI * 2;
                        const distance = Math.random() * 100 + 50;
                        const endX = 50 + Math.cos(angle) * distance;
                        const endY = 50 + Math.sin(angle) * distance;

                        const keyframes = `
                            @keyframes moveParticle {
                                to {
                                    transform: translate(${endX - 50}px, ${endY - 50}px);
                                    opacity: 0;
                                }
                            }
                        `;

                        const style = document.createElement('style');
                        style.innerHTML = keyframes;
                        document.head.appendChild(style);

                        fragment.appendChild(particle);
                    }
                    particles.appendChild(fragment);

                    setTimeout(() => {
                        particles.innerHTML = '';
                    }, 1000);
                }

                // è®¡æ—¶å™¨åŠŸèƒ½
                function startTimer() {
                    gameState.startTime = Date.now();
                    gameState.currentTime = 0;
                    clearInterval(gameState.timerInterval);
                    
                    gameState.timerInterval = setInterval(() => {
                        if (!gameState.isPaused && !gameState.isGameOver) {
                            gameState.currentTime = Date.now() - gameState.startTime;
                            elements.timer.textContent = formatTime(gameState.currentTime);
                        }
                    }, 10);
                }

                // æ ¼å¼åŒ–æ—¶é—´
                function formatTime(ms) {
                    const date = new Date(ms);
                    const minutes = date.getUTCMinutes().toString().padStart(2, '0');
                    const seconds = date.getUTCSeconds().toString().padStart(2, '0');
                    const milliseconds = Math.floor(date.getUTCMilliseconds() / 10).toString().padStart(2, '0');
                    return `${minutes}:${seconds}.${milliseconds}`;
                }

                // è·å–æœ€ä½³æ—¶é—´
                function getBestTime(level) {
                    try {
                        const bestTimesStr = localStorage.getItem('mazeBestTimes');
                        if (!bestTimesStr) return null;
                        const bestTimes = JSON.parse(bestTimesStr);
                        return bestTimes[level] || null;
                    } catch (error) {
                        console.error('è·å–æœ€ä½³æ—¶é—´å¤±è´¥:', error);
                        return null;
                    }
                }

                // è®¾ç½®æœ€ä½³æ—¶é—´
                function setBestTime(level, time) {
                    try {
                        const bestTimesStr = localStorage.getItem('mazeBestTimes');
                        const bestTimes = bestTimesStr ? JSON.parse(bestTimesStr) : {};
                        bestTimes[level] = time;
                        localStorage.setItem('mazeBestTimes', JSON.stringify(bestTimes));
                    } catch (error) {
                        console.error('ä¿å­˜æœ€ä½³æ—¶é—´å¤±è´¥:', error);
                    }
                }

                // åˆ‡æ¢æš‚åœçŠ¶æ€
                function togglePause() {
                    gameState.isPaused = !gameState.isPaused;
                    elements.pauseBtn.textContent = gameState.isPaused ? 'ç»§ç»­' : 'æš‚åœ';
                    
                    if (gameState.isPaused) {
                        clearInterval(gameState.timerInterval);
                    } else {
                        gameState.startTime = Date.now() - gameState.currentTime;
                        startTimer();
                    }
                }

                // é‡æ–°å¼€å§‹å½“å‰å…³å¡
                function restartLevel() {
                    gameState.isPaused = false;
                    gameState.isGameOver = false;
                    elements.pauseBtn.textContent = 'æš‚åœ';
                    generateMaze(levels[gameState.currentLevel - 1]);
                    startTimer();
                    renderMaze();
                }

                // åˆ‡æ¢å…³å¡
                function changeLevel(level) {
                    if (level < 1 || level > levels.length) return;
                    
                    gameState.currentLevel = level;
                    gameState.isPaused = false;
                    gameState.isGameOver = false;
                    elements.pauseBtn.textContent = 'æš‚åœ';
                    elements.currentLevel.textContent = level;
                    
                    generateMaze(levels[level - 1]);
                    startTimer();
                    renderMaze();
                }

                // æ›´æ–°å…³å¡æŒ‰é’®çŠ¶æ€
                function updateLevelButtons() {
                    elements.levelBtns.forEach(btn => {
                        const level = parseInt(btn.dataset.level);
                        btn.disabled = level > gameState.maxUnlockedLevel;
                    });
                }

                // åˆ‡æ¢æç¤ºæ˜¾ç¤º
                function toggleHint() {
                    gameState.showHint = !gameState.showHint;
                    elements.hintBtn.textContent = gameState.showHint ? 'æ¢å¤' : 'æç¤º';
                    renderMaze();
                }

                // ç”Ÿæˆæç¤ºè·¯å¾„ (ä½¿ç”¨A*ç®—æ³•)
                function generateHintPath() {
                    const { maze, playerPosition, exitPosition } = gameState;
                    const openSet = [];
                    const closedSet = [];
                    const path = [];
                    
                    // ç®€åŒ–ç‰ˆçš„è·¯å¾„æŸ¥æ‰¾ - å®é™…åº”ç”¨ä¸­å¯ä»¥ä½¿ç”¨æ›´å¤æ‚çš„ç®—æ³•å¦‚A*
                    // è¿™é‡Œä½¿ç”¨ä¸€ä¸ªç®€åŒ–çš„BFSå®ç°
                    const queue = [{ x: playerPosition.x, y: playerPosition.y, path: [] }];
                    const visited = Array(maze.length).fill().map(() => 
                        Array(maze[0].length).fill(false)
                    );
                    
                    visited[playerPosition.y][playerPosition.x] = true;
                    
                    const directions = [
                        [1, 0], [-1, 0], [0, 1], [0, -1]
                    ];
                    
                    while (queue.length > 0) {
                        const current = queue.shift();
                        
                        if (current.x === exitPosition.x && current.y === exitPosition.y) {
                            gameState.hintPath = current.path;
                            return;
                        }
                        
                        for (const [dx, dy] of directions) {
                            const nx = current.x + dx;
                            const ny = current.y + dy;
                            
                            if (nx >= 0 && nx < maze[0].length && 
                                ny >= 0 && ny < maze.length && 
                                maze[ny][nx] === 0 && !visited[ny][nx]) {
                                
                                visited[ny][nx] = true;
                                queue.push({ 
                                    x: nx, 
                                    y: ny, 
                                    path: [...current.path, { x: nx, y: ny }] 
                                });
                            }
                        }
                    }
                    
                    gameState.hintPath = [];
                }

                // çª—å£å¤§å°æ”¹å˜æ—¶é‡æ–°è®¡ç®—
                window.addEventListener('resize', () => {
                    try {
                        calculateCellSize();
                        renderMaze();
                    } catch (error) {
                        console.error('çª—å£å¤§å°å˜åŒ–å¤„ç†å¤±è´¥ï¼š', error);
                    }
                });

                // åˆå§‹åŒ–æ¸¸æˆ
                initGame();
            } catch (error) {
                console.error('æ¸¸æˆå¯åŠ¨å¤±è´¥:', error);
                alert('æ¸¸æˆå¯åŠ¨å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
            }
        });
    </script>
</body>
</html>
